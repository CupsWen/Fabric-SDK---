<center>
    <font face="宋体" color="black" size="4">
        <h1>下一步的工作</h1>
    </font>
</center>
<font face="宋体" color="black" size="4">
    <p>&nbsp;&nbsp;下一步的工作：</p>
    <p>&nbsp;&nbsp;1、消息队列中数据的备份。中间件最典型的代表是消息中间件（Kafka、RocketMQ之类的），他们都要求通过自己传达的消息要保存在本地。
        在Fabric中间件设计中，希望做到的尽可能的简化、尽可能的让效率提上去。
        没有考虑消息通过内存==>日志==>数据库以及定期备份等操作。
        尽可能的设计一个完备的小的系统是符合前期的设计目标的，下一步看如何进行设计吧。
    </p>
    <p>&nbsp;&nbsp;2、集群。多个Fabric SDK中间件做一个集群提高容错能力。如何将将多个Fabric SDK组成一个集群。</p>
    <p>&nbsp;&nbsp;3、内存管理。目前的系统内存回收太慢，例如：一个工作进程初始化时占用内存50M左右；工作状态内存占用100M左右，且内存回收及其缓慢；内存完全回收完毕后每个进程内存占用约16M。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;原因如下：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;1、Node的内存回收是在闭包程序再次调用时，即事件再次触发时回收上次调用时间回调函数所申请的变量内存。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;2、等待Node自己规定的时间到期后，回收内存。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;如何解决：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;方案一：进程工作完就销毁直接释放内存。优点：内存回收及时。缺点：进程的启动需要消耗时间。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;方案二：手动回收内存，即给变量赋值为undefined。优点：内存回收及时。缺点：内存回收不一定能做全，如函数返回值的变量就无法回收，因为函数已经退出了，不会执行下面的回收代码。</p>
    <p>&nbsp;&nbsp;4、消息队列管理。消息队列目前大概能存储200W消息(前期测试消息队列的时候试的，200W时未报错，2000w报错)。消息队列存储于内存中是不合适的，起码也得缓存。先看看缓存如何设计。</p>
</font>